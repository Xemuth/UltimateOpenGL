#include "Shader.h"

//**********************Shader******************************
//**********************Struct shader_Data
Shader::shader_Data::shader_Data(){}
Shader::shader_Data::shader_Data(Upp::String _name,ShaderType _type,Upp::String _shader){
	name = _name;
	type = _type;
	shader = _shader;
}
Shader::shader_Data& Shader::shader_Data::operator=(const shader_Data& data){
	name= data.name;
	shader = data.shader;
	type = data.type;
	return *this;
}
//**End Struct shader_Data
Shader::Shader(){}
Shader::Shader(Upp::String _name,ShaderType _type,Upp::String _shader){
	shaders.Add(_name,shader_Data(_name,_type, _shader));
}
Shader::Shader(const Shader& _shader){
	shaders.Clear();
	for(const Upp::String &key : _shader.GetShaders().GetKeys()){
		shaders.Add(key,_shader.GetShaders().Get(key));
	}
	compiled = _shader.IsCompiled();
	if(compiled)ID = _shader.GetId();
}
Shader& Shader::operator=(const Shader& data){
	shaders.Clear();
	for(const Upp::String &key : data.GetShaders().GetKeys()){
		shaders.Add(key,data.GetShaders().Get(key));
	}
	compiled = data.IsCompiled();
	if(compiled)ID = data.GetId();
	return *this;
}

Shader::~Shader(){
}

const Upp::VectorMap<Upp::String,Shader::shader_Data>& Shader::GetShaders() const{
	return shaders;
}
Shader& Shader::AddShader(Upp::String _name,ShaderType _type,Upp::String _shader){
	shaders.Add(_name,shader_Data(_name,_type,IncludeShader(_shader)));
	return *this;
}
unsigned int Shader::GetId()const{
	if(!compiled) Upp::Cout() << "Warning GetId() : you're asking for Id while the shader is not compiled ! It mean the return value is wrong...\n";
	return ID;
}
bool Shader::IsCompiled()const{
	return compiled;
}
bool Shader::IsAutoGenerated() const{
	return autoGenerated;
}

bool Shader::CompileShader(bool isAutoGenerated){
	if(!compiled){
		if( shaders.GetCount() ){
			Upp::Vector<unsigned int> RdyToCompile;
			for (const Upp::String &n : shaders.GetKeys()){
				unsigned int buff;
				if(shaders.Get(n).type == FRAGMENT){
					buff = glCreateShader(GL_FRAGMENT_SHADER);
					char str[shaders.Get(n).shader.GetCount()+1];
					char * ptr =str; 		
					
					Upp::FileOut out("./fragment.txt");
					if(out){
						out << 	shaders.Get(n).shader << Upp::EOL;
						out.Close();
					}
					
					strcpy(ptr,shaders.Get(n).shader.ToStd().c_str());
				    glShaderSource(buff, 1, const_cast<const char**>(&ptr), NULL);
				    glCompileShader(buff);
				    if(CheckCompileErrors(buff, FRAGMENT)){
				        RdyToCompile.Add(buff);
					}
				}else if(shaders.Get(n).type == VERTEX){
					buff = glCreateShader(GL_VERTEX_SHADER);
					char str[shaders.Get(n).shader.GetCount()+1];
					char * ptr =str; 
					
					Upp::FileOut out("./vertex.txt");
					if(out){
						out << 	shaders.Get(n).shader << Upp::EOL;
						out.Close();
					}
					
					strcpy(ptr,shaders.Get(n).shader.ToStd().c_str());
				    glShaderSource(buff, 1, const_cast<const char**>(&ptr), NULL);
				    glCompileShader(buff);
				    if(CheckCompileErrors(buff, VERTEX)){
				        RdyToCompile.Add(buff);
				    }
				}
			}
			ID = glCreateProgram();
			for(unsigned int &i : RdyToCompile){
				glAttachShader(ID, i);
			}
		    glLinkProgram(ID);
			for(unsigned int &i : RdyToCompile){
				glDeleteShader(i);
			}
		    RdyToCompile.Clear();
		    if( CheckCompileErrors(ID, PROGRAMM)){
				compiled = true;
				if(isAutoGenerated) autoGenerated=true;
				return  true;
		    }
		    return false;
		}
		return false;
	}else{
		return true;
	}
}
void Shader::Use(){
    glUseProgram(ID);
}

void Shader::Unbind(){
	glUseProgram(0);
}

void Shader::SetBool(Upp::String name, bool value) const{
    glUniform1i(glGetUniformLocation(ID, name.ToStd().c_str()), (int)value);
}
void Shader::SetInt(Upp::String name, int value) const{
    glUniform1i(glGetUniformLocation(ID, name.ToStd().c_str()), value);
}
void Shader::SetFloat(Upp::String name, float value) const{
    glUniform1f(glGetUniformLocation(ID, name.ToStd().c_str()), value);
}
void Shader::SetVec2(Upp::String name, const glm::vec2 &value) const{
    glUniform2fv(glGetUniformLocation(ID, name.ToStd().c_str()), 1, &value[0]);
}
void Shader::SetVec2(Upp::String name, float x, float y) const{
    glUniform2f(glGetUniformLocation(ID, name.ToStd().c_str()), x, y);
}
void Shader::SetVec3(Upp::String name, const glm::vec3 &value) const{
    glUniform3fv(glGetUniformLocation(ID, name.ToStd().c_str()), 1, &value[0]);
}
void Shader::SetVec3(Upp::String name, float x, float y, float z) const{
    glUniform3f(glGetUniformLocation(ID, name.ToStd().c_str()), x, y, z);
}
void Shader::SetVec4(Upp::String name, const glm::vec4 &value) const{
    glUniform4fv(glGetUniformLocation(ID, name.ToStd().c_str()), 1, &value[0]);
}
void Shader::SetVec4(Upp::String name, float x, float y, float z, float w){
    glUniform4f(glGetUniformLocation(ID, name.ToStd().c_str()), x, y, z, w);
}
void Shader::SetMat2(Upp::String name, const glm::mat2 &mat) const{
    glUniformMatrix2fv(glGetUniformLocation(ID, name.ToStd().c_str()), 1, GL_FALSE, &mat[0][0]);
}
void Shader::SetMat3(Upp::String name, const glm::mat3 &mat) const{
    glUniformMatrix3fv(glGetUniformLocation(ID, name.ToStd().c_str()), 1, GL_FALSE, &mat[0][0]);
}
void Shader::SetMat4(Upp::String name, const glm::mat4 &mat) const{
    glUniformMatrix4fv(glGetUniformLocation(ID, name.ToStd().c_str()), 1, GL_FALSE, &mat[0][0]);
}

void Shader::SetPointLight(Upp::String name, const PointLight &pointLight,int num) const{
	if(autoGenerated && num!= -1 ){
		name ="pointLights["+ Upp::AsString(num)+"]";
	}
	SetVec3(name+".position",pointLight.position);	
	SetVec3(name+".ambient", pointLight.ambient);
	SetVec3(name+".diffuse", pointLight.diffuse);
	SetVec3(name+".specular", pointLight.specular);
	SetFloat(name+".constant",pointLight.constant);
	SetFloat(name+".linear",pointLight.linear);
	SetFloat(name+".quadratic",pointLight.quadratic);
}
void Shader::SetDirLight(Upp::String name, const DirLight &dirLight,int num) const{
	if(autoGenerated && num!= -1 ){
		name ="dirLights["+ Upp::AsString(num)+"]";
	}
	SetVec3(name+".direction", dirLight.direction);
	SetVec3(name+".ambient", dirLight.ambient);
	SetVec3(name+".diffuse", dirLight.diffuse);
	SetVec3(name+".specular", dirLight.specular);
}
void Shader::SetSpotLight(Upp::String name, const SpotLight &spotLight,int num) const{
	if(autoGenerated && num!= -1 ){
		name ="spotLights["+ Upp::AsString(num)+"]";
	}
	SetVec3(name+".direction", spotLight.direction);
	SetVec3(name+".position", spotLight.position);
	SetVec3(name+".ambient", spotLight.ambient);
	SetVec3(name+".diffuse", spotLight.diffuse);
	SetVec3(name+".specular", spotLight.specular);
	SetFloat(name+".constant",spotLight.constant);
	SetFloat(name+".linear",spotLight.linear);
	SetFloat(name+".quadratic",spotLight.quadratic);
	SetFloat(name+".cutOff",spotLight.cutOff);
	SetFloat(name+".outerCutOff",spotLight.outerCutOff);
}

void Shader::SetMaterialColor(Upp::String name, const MaterialColor &materialColor) const{
	SetVec3(name+".ambient",materialColor.ambient);
	SetVec3(name+".diffuse",materialColor.diffuse);
	SetFloat(name+".shininess",materialColor.shininess);
	SetVec3(name+".specular",materialColor.specular);
}
void Shader::SetMaterialTexture(Upp::String name,MaterialTexture &materialTexture,bool CheckSpecular) const{
//	Upp::Cout() << "Passing to "  << name << " iterator diffuse number " << materialTexture.diffuse << "\n";
	SetInt(name+".diffuse",materialTexture.diffuse);
	SetFloat(name+".shininess",materialTexture.shininess);
	if(CheckSpecular && materialTexture.specular != -1){
		materialTexture.useSpecular = 1;
		SetInt(name+".useSpecular",1);
		SetInt(name+".specular",materialTexture.specular);
	}else{
		SetInt(name+".useSpecular",materialTexture.useSpecular);
		SetInt(name+".specular",0);
	}
}
bool Shader::CheckCompileErrors(unsigned int shader, ShaderType type)
{
    int success;
    char infoLog[1024];
    if (type == VERTEX || type == FRAGMENT) {
        glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
        if (!success)
        {
            glGetShaderInfoLog(shader, 1024, NULL, infoLog);
            Upp::String buffer;
            if(type == VERTEX) {
                buffer ="VERTEX";
            } else if(type == FRAGMENT) {
                  buffer ="FRAGMENT";
            } else {
                buffer ="UNKNOW";
            }
            Upp::Cout() << "ERROR::"<< buffer <<"_SHADER_COMPILATION_ERROR :\n" << infoLog << "\n";
            return false;
        }
        return true;
    } else if(type == PROGRAMM) {
        glGetProgramiv(shader, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(shader, 1024, NULL, infoLog);
	        Upp::Cout() <<  "ERROR::PROGRAM_LINKING_ERROR :\n" << infoLog << "\n";
			return false;
        }
        return true;
    }
    return false;
}
