#ifndef _UltimateOpenGL_Shader_h_
#define _UltimateOpenGL_Shader_h_
#include "Definition.h"
//*****************Material***********//
struct TextureInformation{
		Texture texture;
		Texture Specular;
		// IF their is other kind of teture to add we must set it here and Update Generate
		// Shader
		float mix = 1.0f;
		
		TextureInformation& SetTexture(Texture& _texture);
		TextureInformation& SetSpecular(Texture& _specular);
		TextureInformation& SetMix(float _mix = 1.0f);
};

class Material{
	private:
		float shininess=32.0f; //Brilliance en fran√ßais
		float diffuse=0.64f; //Valeur de diffusion

		glm::vec3 ambient=glm::vec3(1.0f, 0.5f, 0.31f);
	    glm::vec3 specular=glm::vec3(0.5f, 0.5f, 0.5f);

		enum WhatToUse{TEXTURE, COLOR, BOTH};
		WhatToUse whatToUse = COLOR;// what to use.
		Upp::Array<TextureInformation> TextureToUse; //the float is used to setUp the MixValue of texture. If you only have one texture set it to One.
															  //If you have 2 textures and want a 50%/50% set it to 0.5f to boath texture.
										  
		bool defaultColor = true; //used to know if this material have been modified and should be use.
		glm::vec4 color = glm::vec4( glm::vec3(1,1,1),1.0f); //Color with Alpha
	public:
		Material()= default;
		Material(const Material& material);
		Material& operator=(const Material& material);
		
		Material& UseTextures();
		Material& UseColor();
		Material& UseBoth();

		Material& SetColor(int red,int green, int blue, int alpha);
		Material& SetColor(glm::vec4 _color);
		Material& SetColor(glm::vec3 _color);
		
		Material& SetDiffuse(float _diffuse);
		Material& SetShininess(float _shininess);
		Material& SetAmbient(glm::vec3 _ambient);
		Material& SetSpecular(glm::vec3 _specular);
		
		glm::vec4 GetColor();
		glm::vec3 GetAmbient();
		glm::vec3 GetSpecular();
		float GetShininess();
		float GetDiffuse();
		
		TextureInformation& AddTexture(Texture& t1, float MixValueInPourcentage = 1.0f, Texture tSpeculare = Texture());
		Material& RemoveTexture(int iterator =0);
		Upp::Array<TextureInformation>& GetTextures();
		
		bool HaveBeenSetUp(); //Used to know if this Material have been setting up (to know if UOGL should use it).
};

class Shader {
private:
	struct shader_Data{
		shader_Data();
		shader_Data(Upp::String _name,ShaderType _type,Upp::String _shader);
		shader_Data& operator=(const shader_Data& data);
		
		Upp::String name;
		ShaderType type;
		Upp::String shader;
	};
// utility function for checking shader compilation/linking errors.
	Upp::ArrayMap<Upp::String,shader_Data> shaders;
	unsigned int ID;
	bool Compiled = false;
	bool AutoGenerated = false;
	bool CheckCompileErrors(unsigned int shader, ShaderType type);
public:
    Shader();
    Shader(Upp::String _name,ShaderType _type,Upp::String _shader);
    Shader(const Shader& _shader);
    Shader& operator=(const Shader& data);
	~Shader();

    Shader& AddShader(Upp::String _name,ShaderType _type,Upp::String _shader);
    Upp::ArrayMap<Upp::String,Shader::shader_Data>& GetShaders();

    bool IsCompiled() const;
    bool IsAutoGenerated() const;
    unsigned int GetId() const;

    Shader& SetBool(Upp::String name, bool value) const;
    Shader& SetInt(Upp::String name, int value) const;
    Shader& SetFloat(Upp::String name, float value) const;

	Shader& SetVec2(Upp::String name, const glm::vec2 &value) const;
	Shader& SetVec2(Upp::String name, float x, float y) const;
	Shader& SetVec3(Upp::String name, const glm::vec3 &value) const;
	Shader& SetVec3(Upp::String name, float x, float y, float z) const;
	Shader& SetVec4(Upp::String name, const glm::vec4 &value) const;
	Shader& SetVec4(Upp::String name, float x, float y, float z, float w);
	Shader& SetMat2(Upp::String name, const glm::mat2 &mat) const;
	Shader& SetMat3(Upp::String name, const glm::mat3 &mat) const;
	Shader& SetMat4(Upp::String name, const glm::mat4 &mat) const;
	/*
	Shader& SetPointLight(Upp::String name, const PointLight &pointLight,int num =-1) const;
	Shader& SetDirLight(Upp::String name, const DirLight &dirLight,int num =-1) const;
	Shader& SetSpotLight(Upp::String name, const SpotLight &spotLight,int num =-1) const;
	
	Shader& SetMaterialColor(Upp::String name, Material &materialColor) const;
	Shader& SetMaterialTexture(Upp::String name, Material &materialTexture,bool CheckSpecular=true) const;
	*/
	bool Load(bool autoGenerated =false);
	bool Reload(bool autoGenerated =false);
	bool Unload();
	Shader& Use();
	Shader& Unbind();
};
#endif
